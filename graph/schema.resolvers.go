package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strconv"

	"github.com/MinhDuy27/Ecommerce-App/domain"
	"github.com/MinhDuy27/Ecommerce-App/graph/model"
	"github.com/MinhDuy27/Ecommerce-App/internal/dto"
)

// SignUp is the resolver for the SignUp field.
func (r *mutationResolver) SignUp(ctx context.Context, input *model.NewUser) (*model.Message, error) {
	logindto := dto.Logindto{
		Email:    input.Email,
		Password: input.Password,
	}
	SignUpdto := dto.SignUpdto{
		Logindto: logindto,
		Phone:    input.Phone,
	}
	value, err := r.Usv.SignUp(SignUpdto)
	if err != nil {
		return nil, err
	}
	message := model.Message{
		Message: value,
	}
	return &message, nil
}

// UpdUser is the resolver for the UpdUser field.
func (r *mutationResolver) UpdUser(ctx context.Context, id string, input *model.UpdateUser) (*model.Message, error) {
	User := domain.User{
		FirstName: func() string {
			if input.FirstName != nil {
				return *input.FirstName
			}
			return ""
		}(),
		LastName: func() string {
			if input.LastName != nil {
				return *input.LastName
			}
			return ""
		}(),
		Phone: func() string {
			if input.Phone != nil {
				return *input.Phone
			}
			return ""
		}(),
	}
	uint_id, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		log.Fatal(err)
		return nil, errors.New("cannot parse id")
	}
	_, err = r.Usv.Repo.FindUserById(uint(uint_id))
	if err != nil {
		log.Fatal(err)
		return &model.Message{}, errors.New("cannot find user")
	}
	_, err = r.Usv.Repo.UpdateUser(uint(uint_id), User)
	if err != nil {
		log.Fatal(err)
		return &model.Message{}, errors.New("cannot update user")
	}
	message := model.Message{
		Message: "update success",
	}
	return &message, nil
}

// DelProduct is the resolver for the DelProduct field.
func (r *mutationResolver) DelProduct(ctx context.Context, id string) (*model.Message, error) {
	Uint_id, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return nil, err
	}
	if err = r.Psv.Repo.DeleteProduct(uint(Uint_id)); err != nil {
		return nil, err
	}
	return &model.Message{Message: "delete success"}, nil
}

// UpdProduct is the resolver for the UpdProduct field.
func (r *mutationResolver) UpdProduct(ctx context.Context, id string, input *model.UpdateProduct) (*model.Message, error) {
	Uint_id, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return nil, err
	}

	// Create the UpdateProductDto with pointer fields
	Upd := dto.UpdateProductDto{
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Quantity: func() *uint {
			if input.Quantity != nil {
				q := uint(*input.Quantity)
				return &q
			}
			return nil
		}(),
		ImageURL: input.ImageURL,
	}

	// Fetch the existing product
	existingProduct, err := r.Psv.Repo.FindProduct(uint(Uint_id))
	if err != nil {
		return nil, err
	}

	// Update fields if they are provided in the input
	if Upd.Name != nil {
		existingProduct.Name = *Upd.Name
	}
	if Upd.Description != nil {
		existingProduct.Description = *Upd.Description
	}
	if Upd.Price != nil {
		existingProduct.Price = *Upd.Price
	}
	if Upd.Quantity != nil {
		existingProduct.Quantity = *Upd.Quantity
	}
	if Upd.ImageURL != nil {
		existingProduct.Image_url = *Upd.ImageURL
	}

	if err := r.Psv.Repo.UpdateProduct(uint(Uint_id), existingProduct); err != nil {
		log.Fatal(err)
		return nil, err
	}
	return &model.Message{Message: "update success"}, nil
}

// CreProduct is the resolver for the CreProduct field.
func (r *mutationResolver) CreProduct(ctx context.Context, input model.NewProduct) (*model.Message, error) {
	NewProduct := dto.CreateProductDto{
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Quantity:    uint(input.Quantity),
		Image_url:   input.ImageURL,
	}
	if err := r.Psv.Create(NewProduct); err != nil {
		return nil, err
	}
	return &model.Message{Message: "create success"}, nil
}

// CreateTransaction is the resolver for the CreateTransaction field.
func (r *mutationResolver) CreateTransaction(ctx context.Context, id string) (*model.Transaction, error) {
	panic(fmt.Errorf("not implemented: CreateTransaction - CreateTransaction"))
}

// DeleteTransaction is the resolver for the DeleteTransaction field.
func (r *mutationResolver) DeleteTransaction(ctx context.Context, id string) (*model.Message, error) {
	panic(fmt.Errorf("not implemented: DeleteTransaction - DeleteTransaction"))
}

// AddToCart is the resolver for the AddToCart field.
func (r *mutationResolver) AddToCart(ctx context.Context, input model.MalProcutInCart) (*model.Message, error) {
	panic(fmt.Errorf("not implemented: AddToCart - AddToCart"))
}

// RemoveFromCart is the resolver for the RemoveFromCart field.
func (r *mutationResolver) RemoveFromCart(ctx context.Context, intput model.MalProcutInCart) (*model.Message, error) {
	panic(fmt.Errorf("not implemented: RemoveFromCart - RemoveFromCart"))
}

// CreateNewCart is the resolver for the CreateNewCart field.
func (r *mutationResolver) CreateNewCart(ctx context.Context, intput model.MalCart) (*model.Message, error) {
	panic(fmt.Errorf("not implemented: CreateNewCart - CreateNewCart"))
}

// RemoveCart is the resolver for the RemoveCart field.
func (r *mutationResolver) RemoveCart(ctx context.Context, intput model.MalCart) (*model.Message, error) {
	panic(fmt.Errorf("not implemented: RemoveCart - RemoveCart"))
}

// User is the resolver for the User field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	uint_id, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return nil, err
	}
	value, err := r.Usv.GetProfilesByID(uint(uint_id))
	if err != nil {
		return nil, err
	}
	user := model.User{
		Email:     value.Email,
		FirstName: value.FirstName,
		LastName:  value.LastName,
		Phone:     value.Phone,
	}
	return &user, nil
}

// Login is the resolver for the Login field.
func (r *queryResolver) Login(ctx context.Context, input *model.Login) (*model.Message, error) {
	logindto := dto.Logindto{
		Email:    input.Email,
		Password: input.Password,
	}
	message, err := r.Usv.Login(logindto)
	if err != nil {
		return nil, err
	}
	Message := model.Message{
		Message: message,
	}
	return &Message, nil
}

// GetVerificationCode is the resolver for the GetVerificationCode field.
func (r *queryResolver) GetVerificationCode(ctx context.Context, id string) (*model.Message, error) {
	uint_id, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return nil, err
	}
	user, error := r.Usv.GetProfilesByID(uint(uint_id))
	if error != nil {
		return nil, error
	}
	code, error := r.Usv.GetVerificationCode(user)
	if error != nil {
		return nil, error
	}
	string_Val := strconv.FormatUint(uint64(code), 10)
	message := model.Message{
		Message: string_Val,
	}
	return &message, nil
}

// Verification is the resolver for the Verification field.
func (r *queryResolver) Verification(ctx context.Context, input *model.Verify) (*model.Message, error) {
	uint_id, err := strconv.ParseUint(input.ID, 10, 64)
	if err != nil {
		return nil, err
	}
	_, err = r.Usv.GetProfilesByID(uint(uint_id))
	if err != nil {
		return nil, err
	}
	uint_code, err := strconv.ParseUint(input.Code, 10, 64)
	if err != nil {
		return nil, err
	}
	err = r.Usv.VerifyCode(uint(uint_id), uint(uint_code))
	if err != nil {
		return nil, err
	}
	message := model.Message{
		Message: "verify successfully",
	}
	return &message, nil
}

// Product is the resolver for the Product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*model.Product, error) {
	Int_id, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return &model.Product{}, err
	}
	value, err := r.Psv.Repo.FindProduct(uint(Int_id))
	if err != nil {
		return &model.Product{}, err
	}
	product := model.Product{
		Name:        value.Name,
		Description: value.Description,
		Price:       value.Price,
		Quantity:    int(value.Quantity),
		ImageURL:    value.Image_url,
	}
	return &product, nil
}

// AllProduct is the resolver for the AllProduct field.
func (r *queryResolver) AllProduct(ctx context.Context, amount int) ([]*model.Product, error) {
	res, err := r.Psv.Repo.GetAllProduct(amount)
	if err != nil {
		return nil, err
	}
	var products []*model.Product
	for _, value := range res {
		product := &model.Product{
			Name:        value.Name,
			Description: value.Description,
			Price:       value.Price,
			Quantity:    int(value.Quantity),
			ImageURL:    value.Image_url,
		}
		products = append(products, product)
	}
	return products, nil
}

// Transaction is the resolver for the Transaction field.
func (r *queryResolver) Transaction(ctx context.Context, id *string) (*model.Transaction, error) {
	panic(fmt.Errorf("not implemented: Transaction - Transaction"))
}

// AllTransaction is the resolver for the AllTransaction field.
func (r *queryResolver) AllTransaction(ctx context.Context, amount int) ([]*model.Transaction, error) {
	panic(fmt.Errorf("not implemented: AllTransaction - AllTransaction"))
}

// Cart is the resolver for the Cart field.
func (r *queryResolver) Cart(ctx context.Context, id *string) (*model.Cart, error) {
	panic(fmt.Errorf("not implemented: Cart - Cart"))
}

// AllCart is the resolver for the AllCart field.
func (r *queryResolver) AllCart(ctx context.Context, amount int) ([]*model.Cart, error) {
	panic(fmt.Errorf("not implemented: AllCart - AllCart"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
